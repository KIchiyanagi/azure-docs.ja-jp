---
title: "Azure Service Fabric のレプリカとインスタンス | Microsoft Docs"
description: "レプリカ、インスタンス、それらの機能とライフサイクルについて説明します。"
services: service-fabric
documentationcenter: .net
author: appi101
manager: anuragg
editor: 
ms.assetid: d5ab75ff-98b9-4573-a2e5-7f5ab288157a
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/23/2017
ms.author: aprameyr
ms.translationtype: HT
ms.sourcegitcommit: c3a2462b4ce4e1410a670624bcbcec26fd51b811
ms.openlocfilehash: 794cbed0f5072bcc1c18343b9896aad464861c45
ms.contentlocale: ja-jp
ms.lasthandoff: 09/25/2017

---

# <a name="replicas-and-instances"></a>レプリカとインスタンス 
この記事では、ステートフル サービスのレプリカとステートレス サービスのインスタンスのライフサイクルの概要を示します。

## <a name="instances-of-stateless-services"></a>ステートレス サービスのインスタンス
ステートレス サービスのインスタンスとは、クラスターのノードのいずれかで実行されているサービスのロジックのコピーのことです。 パーティション内のインスタンスは、その InstanceId によって一意に識別されます。 インスタンスのライフサイクルは、次の図のようにモデル化できます。

![インスタンスのライフサイクル](./media/service-fabric-concepts-replica-lifecycle/instance.png)

### <a name="inbuild-ib"></a>InBuild (IB)
クラスター リソース マネージャーで、インスタンスの配置を認識されると、このライフサイクルの状態に入ります。 この時点で、インスタンスがノードで起動します (アプリケーション ホストが起動し、インスタンスが作成されて開かれます)。 起動が完了すると、インスタンスは準備完了状態に遷移します。 

アプリケーション ホストまたはこのインスタンスのノードがクラッシュした場合は、ドロップ状態に遷移します。

### <a name="ready-rd"></a>Ready (RD)
準備完了 (Ready) 状態では、インスタンスはノード上で稼働中です。 これが信頼性の高いサービスであれば、RunAsync が呼び出されています。 

アプリケーション ホストまたはこのインスタンスのノードがクラッシュした場合は、ドロップ状態に遷移します。

### <a name="closing-cl"></a>Closing (CL)
クローズ中 (Closing) 状態では、Service Fabric はこのノード上のインスタンスをシャットダウン処理中です。 この状態は、アプリケーションのアップグレード、負荷分散、またはサービスの削除など、多くの理由により発生します。 シャットダウンが完了すると、ドロップ状態に遷移します。

### <a name="dropped-dd"></a>Dropped (DD)
ドロップ (Dropped) 状態では、既にインスタンスはノード上で実行されていません。 この時点では、Service Fabric はこのインスタンスに関するメタデータを保持しています (遅延削除されます)。

> [!NOTE]
> `Remove-ServiceFabricReplica` で ForceRemove オプションを使用して、いずれかの状態からドロップ状態に遷移することが可能です。
>

## <a name="replicas-of-stateful-services"></a>ステートフル サービスのレプリカ
ステートフル サービスのレプリカとは、クラスターのノードのいずれかで実行されているサービスのロジックのコピーのことです。 さらに、レプリカは、そのサービスの状態のコピーを保持します。 ステートフル レプリカのライフサイクルと動作を説明する 2 つの関連する概念があります。
- レプリカのライフサイクル
- レプリカのロール

次の解説では、永続化ステートフル サービスについて説明します。 揮発性 (メモリ内) のステートフル サービスでは、ダウン状態とドロップ状態は同等です。

![レプリカのライフサイクル](./media/service-fabric-concepts-replica-lifecycle/replica.png)

### <a name="inbuild-ib"></a>InBuild (IB)
InBuild レプリカは、レプリカ セットに加えるために作成中または準備中のレプリカです。 レプリカのロールによっては、IB は異なるセマンティクスを持ちます。 

アプリケーション ホストまたは InBuild レプリカのノードがクラッシュした場合には、ダウン状態に遷移します。

####<a name="primary-inbuild-replicas"></a>Primary InBuild レプリカ 
Primary InBuild は、パーティションの最初のレプリカです。 これは通常、パーティションの作成中に発生します。 Primary InBuild レプリカは、パーティションのすべてのレプリカが再起動またはドロップされるときにも発生します。

####<a name="idlesecondary-inbuild-replicas"></a>IdleSecondary InBuild レプリカ
これらは、クラスター リソース マネージャーによって作成されている新しいレプリカの可能性があります。 または、ダウンし、セットに戻す必要のある既存のレプリカの可能性もあります。 それらのレプリカが ActiveSecondary としてレプリカ セットに加わり、操作のクォーラム確認に参加するためには、まずプライマリによってそれらをシード生成またはビルドする必要があります。

####<a name="activesecondary-inbuild-replicas"></a>ActiveSecondary InBuild レプリカ
一部のクエリで、この状態が見られることがあります。 これは、レプリカ セットに変化がないものの、レプリカをビルドする必要のある最適化です。 レプリカ自体は、通常状態のマシンの遷移に従います (レプリカのロールのセクションで説明されているとおり)。

### <a name="ready-rd"></a>Ready (RD)
準備完了 (Ready) のレプリカは、レプリケーションに参加し、操作のクォーラム確認に参加しているレプリカです。 準備完了状態は、プライマリ レプリカと、アクティブなセカンダリ レプリカに当てはまります。

アプリケーション ホストまたは準備完了レプリカのノードがクラッシュした場合には、ダウン状態に遷移します。

### <a name="closing-cl"></a>Closing (CL)
レプリカは、次のシナリオでクローズ中 (Closing) 状態に入ります。

- **レプリカ用のコードのシャットダウン**: Service Fabric で、レプリカの実行中のコードをシャットダウンすることが必要な場合があります。 これには、さまざまな理由が考えられます。たとえば、アプリケーション、ファブリック、インフラストラクチャのアップグレードや、レプリカによって報告された障害などによって発生します。レプリカのクローズが完了すると、ダウン状態に遷移します。 ディスクに格納されているこのレプリカに関連付けられた永続的な状態は、クリーンアップされません。

- **クラスターからレプリカを削除する**: Service Fabric で、永続的な状態を解除して、レプリカの実行中のコードをシャットダウンすることが必要な場合があります。 負荷分散などの多くの理由が考えられます。

### <a name="dropped-dd"></a>Dropped (DD)
ドロップ (Dropped) 状態では、既にインスタンスはノード上で実行されていません。 ノード上に残される状態もありません。 この時点では、Service Fabric はこのインスタンスに関するメタデータを保持しています (最終的にはそれも削除されます)。

### <a name="down-d"></a>Down (D)
ダウン状態では、レプリカ コードは実行されていませんが、そのレプリカの永続的な状態がそのノードに存在します。 レプリカがダウンする理由はさまざまです。たとえば、ノードのダウン、レプリカ コードでのクラッシュ、アプリケーションのアップグレード、レプリカの障害などです。

ダウン レプリカは、必要に応じて、Service Fabric によって開かれます。たとえば、ノードでのアップグレードが完了したときなどです。

ダウン状態では、レプリカのロールは関係ありません。

### <a name="opening-op"></a>Opening (OP)
Service Fabric がレプリカをバックアップに戻す必要がある場合に、ダウン レプリカはオープン中 (Opening) 状態に入ります。 たとえば、ノード上でアプリケーションのコードのアップグレードが完了した後などに発生します。 

アプリケーション ホストまたはオープン レプリカのノードがクラッシュした場合には、ダウン状態に遷移します。

オープン中 (Opening) 状態では、レプリカのロールは関係ありません。

### <a name="standby-sb"></a>StandBy (SB)
スタンバイ (StandBy) レプリカは、ダウン後に再び開かれた、永続的なサービスのレプリカです。 このレプリカは、レプリカ セットに別のレプリカを追加する必要がある場合に、Service Fabric によって使用される可能性があります (状態の一部が既にあって、ビルド処理が高速であるため)。 StandByReplicaKeepDuration の期限が切れると、スタンバイ レプリカは破棄されます。

アプリケーション ホストまたはスタンバイ レプリカのノードがクラッシュした場合には、ダウン状態に遷移します。

スタンバイ状態では、レプリカのロールは関係ありません。

> [!NOTE]
> ダウン状態でもドロップ状態でもないレプリカは、*稼働中*と見なされます。
>

> [!NOTE]
> `Remove-ServiceFabricReplica` で ForceRemove オプションを使用して、いずれかの状態からドロップ状態に遷移することが可能です。
>

## <a name="replica-role"></a>レプリカのロール 
レプリカのロールは、レプリカ セット内での機能を決定します。

- **Primary (P)**: レプリカ セットには、読み取りおよび書き込み操作の実行を担当する 1 つのプライマリがあります。 
- **ActiveSecondary (S)**: これらは、状態の更新をプライマリから受け取り、それらを適用し、確認を戻すレプリカです。 レプリカ セットには複数のアクティブなセカンダリがあり、それらの数によって、サービスで処理できるエラーの数が決まります。
- **IdleSecondary (I)**: これらのレプリカはプライマリによってビルドされているもので、アクティブなセカンダリに昇格する前に、プライマリから状態を受信します。 
- **None (N)**: これらのレプリカは、レプリカ セットで何も担当しません。
- **Unknown (U)**: Service Fabric から何らかの ChangeRole API 呼び出しを受け取る前の、レプリカの初期ロールです。

次のセクションでは、レプリカのロールの遷移と、それらが発生するいくつかのシナリオ例について説明します。

![レプリカのロール](./media/service-fabric-concepts-replica-lifecycle/role.png)

- U -> P: 新しいプライマリ レプリカの作成
- U -> I: 新しいアイドル レプリカの作成
- U -> N: スタンバイ レプリカの削除
- I -> S: アイドル状態のセカンダリをアクティブなセカンダリに昇格して、その確認がクォーラムに貢献するようにします。
- I -> P: アイドル状態のセカンダリからプライマリへの昇格。 アイドル セカンダリがプライマリの適切な候補になる、特別な再構成のもとで発生する可能性があります。
- I -> N: アイドル状態のセカンダリ レプリカの削除。
- S -> P: アクティブなセカンダリからプライマリへの昇格。 これは、アプリケーションのアップグレードまたは負荷分散などへの応答として、クラスター リソース マネージャーが開始した、プライマリのフェールオーバーまたはプライマリの動きが理由で発生します。
- S -> N: アクティブなセカンダリ レプリカの削除。
- P -> S: プライマリ レプリカの降格。 アプリケーションのアップグレードまたは負荷分散などへの応答として、クラスター リソース マネージャーによって開始されたプライマリの動きが理由で発生します。
- P -> N: プライマリ レプリカの削除。

> [!NOTE]
> [Reliable Actors](service-fabric-reliable-actors-introduction.md) や [Reliable Services](service-fabric-reliable-services-introduction.md) など、抽象度の高いプログラミング モデルの場合、レプリカ ロールの概念は開発者には隠されています。 Reliable Actors では、ロールの概念は不要です。Reliable Services では、ほとんどの場合に大幅に簡略化されます。
>

## <a name="next-steps"></a>次のステップ
Service Fabric の概念について詳しくは、次の記事をご覧ください。

- [Reliable Services のライフサイクル - C#](service-fabric-reliable-services-lifecycle.md)

